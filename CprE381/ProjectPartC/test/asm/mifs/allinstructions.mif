DEPTH=1024; 	% Memory depth and width are required 
		% DEPTH is the number of addresses 
WIDTH = 32; 	% WIDTH is the number of bits of data per word
		% DEPTH and WIDTH should be entered as decimal numbers

ADDRESS_RADIX = DEC; 	% Address and value radixes are required
DATA_RADIX = BIN; 	% Enter BIN, DEC, HEX, OCT, or UNS; unless
			% otherwise specified, radixes = HEX

-- Specify values for addresses, which can be single address or range
-- SOME THINGS TO CONSIDER
-- 1) This memory is word-addressable, versus the MIPS conceptual byte-addressable memory.
--    This means that address 1 corresponds to word 1, address 2 corresponds to word 2, etc.
--    Since MIPS will be generating byte addresses, you will have to create some (very simple)
--    logic in your VHDL wrapper to deal with byte/word offsets. 
-- 2) The "single address" notation seems to be least likely to cause confusion so that is what
--    I recommend. 
-- 3) The values need to be in 32-bit hex form (i.e. don't use F when you really mean 0000000F).

CONTENT
BEGIN

0: 00100000000010010000000000001001;
1: 00110001001010100000000000001000;
2: 10100101001010011111111111111111;
3: 10101101001010100000000000000011;
4: 00000001001010100101100000100000;
5: 00100101000011000000000000100000;
6: 00000001100010110110100000100001;
7: 00000001101010010111000000100100;
8: 00000001101011100111100000100010;
9: 00000001111011101100000000100011;
10: 00000000000010101100100001000000;
11: 00000001001010010100100000000100;
12: 00000001001011101100100000100101;
13: 00110111001110000000000000001111;
14: 00111011001110000000000000001111;
15: 00000011000010010111100000100110;
16: 00001000000000000000000000010011;
17: 00001100000000000000000000101001;
18: 00000011111000000000000000001000;
19: 00111100000011001101100100000011;
20: 00000000000011000101110000000010;
21: 00000000000011000101010000000011;
22: 10001100000011010000000000001100;
23: 00000001101011000101100000000110;
24: 00000001101011000101000000000111;
25: 10100000000011010000000001100100;
26: 10000100000011100000000000001000;
27: 10010100000011110000000000001000;
28: 01110001110011111100000000000010;
29: 00000001110011111100000000100111;
30: 10000000000110010000000001100100;
31: 10010000000110000000000001100100;
32: 00000001111110000100000000101010;
33: 00000011000011110100000000101010;
34: 00000001111110000100000000101011;
35: 00000011000011110100000000101011;
36: 00101011000010000000000000000101;
37: 00101011000010000000000001011011;
38: 00101111000010000000000000000101;
39: 00101111000010000000000001011011;
40: 00001000000000000000000000010001;
41: 00000011111000001111100000001001;
42: 00100000000010000000000000000000;
43: 00010000000010000000000000010001;
44: 00100000000010000000000000000001;
45: 00000101101000010000000000010100;
46: 00111100000000010000000000000010;
47: 00110100001000011100001111011100;
48: 00000000000000010100000000100000;
49: 00000101101100010000000000010100;
50: 00111100000000010000000000000010;
51: 00110100001000011100001111011100;
52: 00000000000000010100000000100000;
53: 00011101101000000000000000010100;
54: 00111100000000010000000000000010;
55: 00110100001000011100001111011100;
56: 00000000000000010100000000100000;
57: 00001000000000000000000001001110;
58: 00111100000000010000000000000010;
59: 00110100001000011100001111011100;
60: 00000000000000010100000000100000;
61: 00100000000010000000000000000010;
62: 00010101000000001111111111101110;
63: 00111100000000010000000000000010;
64: 00110100001000011100001111011100;
65: 00000000000000010100000000100000;
66: 00011001010000001111111111101110;
67: 00111100000000010000000000000010;
68: 00110100001000011100001111011100;
69: 00000000000000010100000000100000;
70: 00000101010000001111111111101110;
71: 00111100000000010000000000000010;
72: 00110100001000011100001111011100;
73: 00000000000000010100000000100000;
74: 00000101010100000000000000000011;
75: 00111100000000010000000000000010;
76: 00110100001000011100001111011100;
77: 00000000000000010100000000100000;

[78..1023] : 00000000000000000000000000000000; 			

END;
